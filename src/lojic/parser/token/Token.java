package lojic.parser.token;

import lojic.parser.LojicLexer;

/**
 * @author AlienIdeology
 *
 * A string sequence that is generated by LojicLexer
 * A token can be a single character, or multiple characters (atom or formula, parenthesized or not)
 */
public class Token implements CharSequence {

    private LojicLexer tokenizer;
    private String string;
    private Type type;
    private int location;

    public Token(LojicLexer tokenizer, String string, Type type) {
        this.tokenizer = tokenizer;
        this.string = string;
        this.type = type;
        this.location = 0;
    }

    public Token(LojicLexer tokenizer, String string, Type type, int location) {
        this.tokenizer = tokenizer;
        this.string = string;
        this.type = type;
        this.location = location;
    }

    public LojicLexer getTokenizer() {
        return tokenizer;
    }

    public int getLocation() {
        return location;
    }

    public void setLocation(int location) {
        this.location = location;
    }

    @Override
    public String toString() {
        return string;
    }

    public Type getType() {
        return type;
    }

    public boolean isType(Type type) {
        return this.type.equals(type);
    }

    @Override
    public int length() {
        return string.length();
    }

    @Override
    public char charAt(int index) {
        return string.charAt(index);
    }

    @Override
    public CharSequence subSequence(int start, int end) {
        return string.substring(start, end);
    }

    /**
     * @author AlienIdeology
     *
     * The type of strings the LojicLexer would encounter and handle accordingly
     */
    public enum Type {

        // Raw type that only next() returns
        PARENTHESIS_OPEN ("(", "(", "{", "["),
        PARENTHESIS_CLOSE (")", ")", "}", "]"),
        UNKNOWN,


        // Processed type which LojicLexer returns
        // Parser replaces PARENTHESIS with FORMULA
        ATOM,
        UNARY_CONNECTIVE,
        BINARY_CONNECTIVE,
        FORMULA;

        public String OFFICIAL_SYMBOL;
        public String[] SYMBOLS;
        // symbols must include the official symbol.
        // If String symbol is defined as symbols[0], there would be an ExceptionInInitializerError

        /**
         * @param symbol The official symbol
         * @param symbols All symbols, including the official one
         */
        Type(String symbol, String... symbols) {
            OFFICIAL_SYMBOL = symbol;
            SYMBOLS = symbols;
        }

        Type(){}

    }

}
